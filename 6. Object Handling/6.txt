=======>
a1.
Object Creation (Literal)
    Object creation (literal) means creating an object directly using {} without using any class, constructor, or function.

    Why ?
    * It's quick and easy to create small objects.
    * Best for simple data structures like settings, configurations, simple records, etc.
    * Readable and clean syntax.

    How ?
    Use curly braces {} and define key: value pairs inside.

    Syntax 
    let obj = {
      key1: value1,
      key2: value2
    };
<=======

=======>
a2.
Object Creation (Constructor)
    Object creation (constructor) means creating objects using a constructor function (special function meant to build objects).
    Itâ€™s a blueprint to create multiple objects with the same structure easily.

    Why?
    * Reuse code to create many similar objects.
    * Dynamic: Each object can have different values.
    * Used when you need a lot of similar objects (like users, products, etc.)

    How ?
    1. Define a function (constructor) with capital first letter (by convention).
    2. Inside, use this.key = value.
    3. Use new keyword to create objects.
<=======

=======>
a3.
Property Access
    Property Access means getting (reading) or setting (changing) the value of a key inside an object.

    Why?
    * To use the object's data.
    * To update or modify properties.
    * To dynamically access keys.

    How?
    There are two ways:
    1. Dot Notation â€” easiest and most common
    2. Bracket Notation â€” useful when the key is dynamic or has special characters
<=======

=======>
a4.
Property Deletion
    Property Deletion means removing a key-value pair from an object completely.

    Why?
    * To clean up unused data.
    * To remove sensitive or temporary properties.
    * To update the object structure.

    How?
    Use the delete keyword.

    Syntax
    delete object.property;     (or)   delete object["property"];
<=======

=======>
a5.
Destructuring
    Destructuring means pulling out properties from an object and storing them directly into variables.
    (Instead of accessing each property manually.)

    Why?
    * Makes code shorter and cleaner.
    * Easier to grab multiple values at once.
    * Organizes your code better.

    How?
    Syntax 
    const { key1, key2 } = object;
<=======

=======>
a6.
Spread Operator
    The spread operator (...) is used to copy or expand properties of one object into another object.
    Basically:
    ðŸ‘‰ Take everything from an object and spread it somewhere else.

    Why?
    * To copy objects easily.
    * To merge objects together.
    * To add or update properties while copying.

    How?
    Syntax 
    const newObject = { ...oldObject };
<=======

=======>
a7.
Rest Operator
    The rest operator (...) is used to collect the remaining properties of an object into a new object after some properties are pulled out.
    ðŸ‘‰ It's like:
    * "Take the rest of the properties and put them together!"

    Why?
    * To extract only what you need.
    * To separate or filter properties easily.
    * To clean up objects without mutating the original.

    How?
    Itâ€™s used inside destructuring like this:
    const { key1, key2, ...rest } = object;
<=======

=======>
a8.
Object.keys()
    Object.keys() is a method that returns an array of the objectâ€™s own property names (keys).
    ðŸ‘‰ Only keys, not values.
    ðŸ‘‰ Only enumerable (visible) properties.

    Why?
    * To get all keys of an object quickly.
    * Useful for looping, validations, or counting properties.

    How?
    Object.keys(object);
<=======

=======>
a9.
Object.values()
<=======

=======>
b1.
Object.entries()
<=======

=======>
b2.
Optional Chaining (?.)
<=======

=======>
b3.
Nullish Coalescing (??)
<=======

=======>
b4.
Object.freeze()
<=======

=======>
b5.
Object.seal()
<=======

=======>
b6.
Shallow Copy
<=======

=======>
b7.
Deep Copy
<=======

=======>
b8.
JSON.parse()
<=======

=======>
b9.
JSON.stringify()
<=======

=======>
c1.
Prototypes
<=======

=======>
c2.
Inheritance
<=======
