=======>
DB Connection
    const mongoose = require("mongoose");
    const mongouri = process.env.MONGODB_URI;

    const connectDB = () => {
    mongoose
        .connect(mongouri)
        .then(() => console.log(`Mongoose connected successfully`))
        .catch((err) => console.log(`Error while connecting to mongo`, err));
    };

    module.exports = connectDB;

a1.
Create Document
    In MongoDB, creating a document means inserting a new JSON-like object into a collection in a database.
    {
        "_id": ObjectId("..."),
        "name": "John",
        "email": "john@example.com"
    }

    Why ?
    You create documents to:
    * Store application data (users, orders, products, etc.)
    * Maintain schema-flexible records
    * Add entries to your collection
    * Build APIs that rely on persistent storage
<=======

=======>
a2.
Read Document
    Reading means querying or retrieving documents from a MongoDB collection.
    This can be:
    * One document â†’ findOne(), findById()
    * Many documents â†’ find(), with filters, projections, sorting, etc.

    why ?
    To:
    * Show user data in dashboards
    * Authenticate users
    * List orders/products
    * Check status, verify inputs
    * Populate dropdowns or relations
    In short: any time we fetch data from DB, we use read queries.
<=======

=======>
a3.
Update Document
    Updating a document means modifying one or more fields in an existing MongoDB record 
    (document) based on a condition â€” typically by _id.

    Why ?
    You use it when:
        * A user updates their profile (name, age, etc.)
        * Admin changes user role or status
        * A productâ€™s price is updated
        * A booking status is changed from pending â†’ confirmed

    You donâ€™t want to delete or recreate the record â€” just update it.
    ðŸ”§ Methods to update (via Mongoose):
        * findByIdAndUpdate
        * updateOne
        * updateMany
        * findOneAndUpdate
        * Document.save()
<=======

=======>
a4.
Delete Document
    Deleting a document means permanently removing a record from your MongoDB collection.
    Mongoose gives you several ways to delete:
        * deleteOne()
        * deleteMany()
        * findByIdAndDelete()
        * findOneAndDelete()
    Thereâ€™s also the soft delete pattern (where you just mark deleted: true).

    Why ?
    In real-world apps, we delete documents when:
        * A user deletes their account
        * Admin removes a product or post
        * An expired session/token is removed
        * An order is canceled and should not appear anymore
    Note: Sometimes, we soft delete instead of hard delete â€” more on that below.
<=======

=======>
a5.
Schema Design
    Schema Design is the process of defining the structure of your documents in a MongoDB collection using fields, 
    types, relationships, constraints, and indexes.
    In Mongoose (Node.js), you define schemas using new mongoose.Schema(), then create models based on that schema.

    Why ?
    * Ensures data consistency (type-safe: name = string, age = number)
    * Controls validation (required, unique, enums, etc.)
    * Improves query performance (via indexing and structure)
    * Supports complex/nested relationships
    * Makes your codebase maintainable and scalable
<=======

=======>
a6.
ObjectId
    ObjectId is the default unique identifier (_id) that MongoDB assigns to every document.
    It's a special 12-byte identifier that looks like this:
    "65143c5a3fd1a509b4a3e123"
    Each ObjectId is globally unique and contains:
    * 4 bytes: timestamp
    * 5 bytes: machine/process ID
    * 3 bytes: counter (auto-increment)

    Why ?
    âœ… It uniquely identifies every document
    âœ… It's automatically generated (no need for UUIDs manually)
    âœ… It's indexed by default (faster search on _id)
    âœ… It stores creation time (can extract when doc was created)
    âœ… It's used to build references between documents (like foreign keys)
<=======

=======>
a7.
Indexing
    Indexing in MongoDB is a way to improve the speed of read/query operations by creating special data structures 
    (indexes) that help MongoDB locate data faster â€” like a bookâ€™s index page.
    * By default, every MongoDB collection creates an index on the _id field.

    Why ?
    âœ… Makes queries much faster
    âœ… Reduces CPU/IO load
    âœ… Essential for large datasets
    âœ… Needed for sorting, filtering, pagination
    âœ… Allows constraints (e.g. unique email)
<=======

=======>
a8.
Aggregation
    Aggregation in MongoDB is a way to process data records and return computed results. It's similar to SQL 
    GROUP BY and JOIN but much more powerful.

    Aggregation uses a "pipeline" where multiple stages (like $match, $group, $sort) are applied one after another 
    to transform the data.

    Why ?
    âœ… To perform complex queries like filtering + grouping + counting
    âœ… To generate reports and dashboards
    âœ… To join multiple collections (with $lookup)
    âœ… To reshape data (projection, computed fields)
    âœ… To perform analytics directly in the DB (instead of in Node.js code)
<=======

=======>
a9.
Mongoose ODM
    Mongoose is an ODM (Object Data Modeling) library for MongoDB and Node.js.
    It helps you interact with MongoDB using JavaScript objects instead of raw database commands.

    Why ?
    | Feature           | Benefit                                                             |
    | ----------------- | ------------------------------------------------------------------- |
    | **Schema-based**  | Enforces structure and validation on MongoDB's flexible documents   |
    | **Models**        | Provides a clean way to define and reuse collections (like classes) |
    | **Validation**    | Built-in and custom validation support                              |
    | **Middleware**    | Add pre/post hooks for things like `save`, `remove`, etc.           |
    | **Query Helpers** | Chainable, promise-based MongoDB queries                            |
    | **Relationships** | Supports population (joins) using `.populate()`                     |
    | **Easy CRUD**     | Simplifies common database operations                               |
<=======

=======>
b1.
Mongoose Validation
    Mongoose validation is a way to enforce rules on your MongoDB documents before they get saved to the database. 
    It helps ensure data integrity by validating fields according to your specified constraints (like required fields,
    min/max length, value ranges, enums, custom validation, etc.).

    Why ?
    * To prevent bad or invalid data from being saved in your database.
    * To ensure data consistency across your application.
    * To provide meaningful errors back to the user or API client.
    * To reduce bugs and unexpected behavior by controlling data shape and values early.
<=======

=======>
b2.
Mongoose Connection
    Mongoose connection refers to connecting your Node.js application to your MongoDB database using the Mongoose library.
    It's how you tell your app:
    "Hereâ€™s the database I want to use."

    Why ?
    * It establishes a link between your code and MongoDB.
    * Without connecting, you canâ€™t read/write/update/delete data.
    * You can define how Mongoose handles errors, retries, timeouts, etc.
    * You can manage connection pooling, events (like on open, error), and more.
<=======

=======>
b3.
Population (populate)
    In Mongoose, populate() is a way to automatically replace the specified path in a document with actual documents 
    from another collection.
    ðŸ‘‰ It's like doing a "JOIN" in SQL â€” MongoDB doesn't support JOINs directly, but Mongoose gives us this feature via populate.

    Why ?
    Imagine you have 2 collections:
        * Users
        * Posts
    Each Post has a reference (userId) to a User. But when you query Posts, you want the full user info, 
    not just the userId.
    Instead of making 2 separate queries, you use populate to "pull in" the user details directly.

    ðŸ§  populate is used to initialize the "foreign key" in MongoDB â€” meaning:
    * You store just the ObjectId of the related document (like userId in a Post)
    * But when you use populate(), Mongoose goes and fetches the actual document (like full user details)
    * It replaces the ObjectId with the full object
<=======

=======>
b4.
Transactions
    MongoDB Transactions allow you to execute multiple operations in an "all-or-nothing" way. That means either all 
    operations succeed, or if any fail â€” all changes are rolled back.
    Think of it like a promise chain:
    * âœ… If everything runs fine â€” commit the changes
    * âŒ If something fails â€” revert everything
    MongoDB transactions are available only on replica sets (or sharded clusters with config) and must be used carefully 
    for performance.

    Why ?
    Real-world use cases:
    * Transferring money between accounts: Debit from A, Credit to B
    * Creating an order: Insert into orders, update product stock
    * Writing to multiple collections that must stay in sync

    Steps in transaction
    step 1 : startSession
    step 2 : start Transaction
    step 3 : if(all good) commitTransaction else abortTransaction => handle abort in catch
    step 4 : endSession
<=======

=======>
b5.
Sharding and Replication
<=======

=======>
b6.
Primary and secondary Replica sets
<=======

=======>
b7.
Schema Migrations
<=======

=======>
b8.
Monitor Performance
<=======
