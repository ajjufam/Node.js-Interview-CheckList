=======>
DB Connection
    const mongoose = require("mongoose");
    const mongouri = process.env.MONGODB_URI;

    const connectDB = () => {
    mongoose
        .connect(mongouri)
        .then(() => console.log(`Mongoose connected successfully`))
        .catch((err) => console.log(`Error while connecting to mongo`, err));
    };

    module.exports = connectDB;

a1.
Create Document
    In MongoDB, creating a document means inserting a new JSON-like object into a collection in a database.
    {
        "_id": ObjectId("..."),
        "name": "John",
        "email": "john@example.com"
    }

    Why ?
    You create documents to:
    * Store application data (users, orders, products, etc.)
    * Maintain schema-flexible records
    * Add entries to your collection
    * Build APIs that rely on persistent storage
<=======

=======>
a2.
Read Document
    Reading means querying or retrieving documents from a MongoDB collection.
    This can be:
    * One document â†’ findOne(), findById()
    * Many documents â†’ find(), with filters, projections, sorting, etc.

    why ?
    To:
    * Show user data in dashboards
    * Authenticate users
    * List orders/products
    * Check status, verify inputs
    * Populate dropdowns or relations
    In short: any time we fetch data from DB, we use read queries.
<=======

=======>
a3.
Update Document
    Updating a document means modifying one or more fields in an existing MongoDB record 
    (document) based on a condition â€” typically by _id.

    Why ?
    You use it when:
        * A user updates their profile (name, age, etc.)
        * Admin changes user role or status
        * A productâ€™s price is updated
        * A booking status is changed from pending â†’ confirmed

    You donâ€™t want to delete or recreate the record â€” just update it.
    ðŸ”§ Methods to update (via Mongoose):
        * findByIdAndUpdate
        * updateOne
        * updateMany
        * findOneAndUpdate
        * Document.save()
<=======

=======>
a4.
Delete Document
    Deleting a document means permanently removing a record from your MongoDB collection.
    Mongoose gives you several ways to delete:
        * deleteOne()
        * deleteMany()
        * findByIdAndDelete()
        * findOneAndDelete()
    Thereâ€™s also the soft delete pattern (where you just mark deleted: true).

    Why ?
    In real-world apps, we delete documents when:
        * A user deletes their account
        * Admin removes a product or post
        * An expired session/token is removed
        * An order is canceled and should not appear anymore
    Note: Sometimes, we soft delete instead of hard delete â€” more on that below.
<=======

=======>
a5.
Schema Design
    Schema Design is the process of defining the structure of your documents in a MongoDB collection using fields, 
    types, relationships, constraints, and indexes.
    In Mongoose (Node.js), you define schemas using new mongoose.Schema(), then create models based on that schema.

    Why ?
    * Ensures data consistency (type-safe: name = string, age = number)
    * Controls validation (required, unique, enums, etc.)
    * Improves query performance (via indexing and structure)
    * Supports complex/nested relationships
    * Makes your codebase maintainable and scalable
<=======

=======>
a6.
ObjectId
    ObjectId is the default unique identifier (_id) that MongoDB assigns to every document.
    It's a special 12-byte identifier that looks like this:
    "65143c5a3fd1a509b4a3e123"
    Each ObjectId is globally unique and contains:
    * 4 bytes: timestamp
    * 5 bytes: machine/process ID
    * 3 bytes: counter (auto-increment)

    Why ?
    âœ… It uniquely identifies every document
    âœ… It's automatically generated (no need for UUIDs manually)
    âœ… It's indexed by default (faster search on _id)
    âœ… It stores creation time (can extract when doc was created)
    âœ… It's used to build references between documents (like foreign keys)
<=======

=======>
a7.
Indexing
    Indexing in MongoDB is a way to improve the speed of read/query operations by creating special data structures 
    (indexes) that help MongoDB locate data faster â€” like a bookâ€™s index page.
    * By default, every MongoDB collection creates an index on the _id field.

    Why ?
    âœ… Makes queries much faster
    âœ… Reduces CPU/IO load
    âœ… Essential for large datasets
    âœ… Needed for sorting, filtering, pagination
    âœ… Allows constraints (e.g. unique email)
<=======

=======>
a8.
Aggregation
    Aggregation in MongoDB is a way to process data records and return computed results. It's similar to SQL 
    GROUP BY and JOIN but much more powerful.

    Aggregation uses a "pipeline" where multiple stages (like $match, $group, $sort) are applied one after another 
    to transform the data.

    Why ?
    âœ… To perform complex queries like filtering + grouping + counting
    âœ… To generate reports and dashboards
    âœ… To join multiple collections (with $lookup)
    âœ… To reshape data (projection, computed fields)
    âœ… To perform analytics directly in the DB (instead of in Node.js code)
<=======

=======>
a9.
Mongoose ODM
    Mongoose is an ODM (Object Data Modeling) library for MongoDB and Node.js.
    It helps you interact with MongoDB using JavaScript objects instead of raw database commands.

    Why ?
    | Feature           | Benefit                                                             |
    | ----------------- | ------------------------------------------------------------------- |
    | **Schema-based**  | Enforces structure and validation on MongoDB's flexible documents   |
    | **Models**        | Provides a clean way to define and reuse collections (like classes) |
    | **Validation**    | Built-in and custom validation support                              |
    | **Middleware**    | Add pre/post hooks for things like `save`, `remove`, etc.           |
    | **Query Helpers** | Chainable, promise-based MongoDB queries                            |
    | **Relationships** | Supports population (joins) using `.populate()`                     |
    | **Easy CRUD**     | Simplifies common database operations                               |
<=======

=======>
b1.
Mongoose Validation
    Mongoose validation is a way to enforce rules on your MongoDB documents before they get saved to the database. 
    It helps ensure data integrity by validating fields according to your specified constraints (like required fields,
    min/max length, value ranges, enums, custom validation, etc.).

    Why ?
    * To prevent bad or invalid data from being saved in your database.
    * To ensure data consistency across your application.
    * To provide meaningful errors back to the user or API client.
    * To reduce bugs and unexpected behavior by controlling data shape and values early.
<=======

=======>
b2.
Mongoose Connection
<=======

=======>
b3.
Population (populate)
<=======