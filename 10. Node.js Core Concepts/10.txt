=======>
a1.
Global Objects
    Global Objects in Node.js are objects available in every module. You don't need to require them — 
    they are automatically available.

    Why?
    * Help you access useful values or functions anywhere in your code.
    * Reduce the need for importing common utilities.
    * Offer system-level functionalities like current directory, timers, buffer handling, etc.
<=======

=======>
a2.
CommonJS Modules
    CommonJS (CJS) is the module system used in Node.js.
    It allows you to import and export code between files.

    Why?
    * Helps split code into reusable parts.
    * Keeps code organized and maintainable.
    * Built-in support in Node.js (no setup needed).
<=======

=======>
a3.
ES Modules
    ES Modules (ESM) is the official JavaScript module system introduced in ES6 (2015).
    It's used in both browser and Node.js (modern versions).

    Why?
    * Native JavaScript module system.
    * Supports asynchronous loading.
    * Works in browsers and Node.js.
    * Supports tree-shaking (removing unused code).
<=======

=======>
a4.
REPL
    🔁 Read
    ⚙️ Eval
    📝 Print
    ⏹️ Loop
    It’s an interactive environment where you can run JavaScript code line-by-line — like a live playground!

    Why?
    * Test small pieces of code quickly 🧪
    * Debug expressions and functions 🐞
    * Explore Node.js APIs easily 🚀
    * No need to create a file or run node file.js 💡
<=======

=======>
a5.
NPM
    NPM stands for Node Package Manager.
    It’s the default package manager for Node.js.

    Why?
    * Install open-source packages (like express, mongoose)
    * Manage project dependencies
    * Run project scripts
    * Share your own packages
<=======

=======>
a6.
Environment Variables
    Environment Variables are key-value pairs used to store config values outside your code.
    🛡️ Useful for keeping sensitive info like passwords, API keys, and URLs secure and separate from code.

    Why?
    🔒 Security – avoid hardcoding secrets
    🔁 Portability – config changes without changing code
    📦 Environment-specific setup – dev, staging, production
<=======

=======>
a7.
fs module
    The fs module in Node.js lets you work with the file system — reading, writing, updating, and deleting 
    files or folders.

    Why?
    To Read, Write, Update, and Delete operations in file system

    How?
    Using fs module
    const fs = require('fs');
<=======

=======>
a8.
path module
    The path module provides utilities for working with file and directory paths in Node.js.
    📦 It's a built-in module — no need to install it.

    Why?
    * Makes file paths OS-independent (/ on mac/linux, \\ on Windows)
    * Helps join, resolve, normalize, extract paths
    * Prevents hardcoding file paths manually

    How?
    Using path module
    const path = require('path');
<=======

=======>
a9.
events module
<=======

=======>
b1.
streams
<=======

=======>
b2.
buffers
<=======

=======>
b3.
http module
<=======

=======>
b4.
os module
<=======

=======>
b5.
child_process
<=======

=======>
b6.
cluster
<=======

=======>
b7.
process.exit()
<=======

=======>
b8.
process.argv
<=======

=======>
b9.
process.memoryUsage()
<=======

=======>
c1.
Manual Middleware
<=======

=======>
c2.
Error Handling
<=======

=======>
c3.
REST APIs
<=======