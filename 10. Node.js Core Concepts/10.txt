=======>
a1.
Global Objects
    Global Objects in Node.js are objects available in every module. You don't need to require them â€” 
    they are automatically available.

    Why?
    * Help you access useful values or functions anywhere in your code.
    * Reduce the need for importing common utilities.
    * Offer system-level functionalities like current directory, timers, buffer handling, etc.
<=======

=======>
a2.
CommonJS Modules
    CommonJS (CJS) is the module system used in Node.js.
    It allows you to import and export code between files.

    Why?
    * Helps split code into reusable parts.
    * Keeps code organized and maintainable.
    * Built-in support in Node.js (no setup needed).
<=======

=======>
a3.
ES Modules
    ES Modules (ESM) is the official JavaScript module system introduced in ES6 (2015).
    It's used in both browser and Node.js (modern versions).

    Why?
    * Native JavaScript module system.
    * Supports asynchronous loading.
    * Works in browsers and Node.js.
    * Supports tree-shaking (removing unused code).
<=======

=======>
a4.
REPL
    ğŸ” Read
    âš™ï¸ Eval
    ğŸ“ Print
    â¹ï¸ Loop
    Itâ€™s an interactive environment where you can run JavaScript code line-by-line â€” like a live playground!

    Why?
    * Test small pieces of code quickly ğŸ§ª
    * Debug expressions and functions ğŸ
    * Explore Node.js APIs easily ğŸš€
    * No need to create a file or run node file.js ğŸ’¡
<=======

=======>
a5.
NPM
    NPM stands for Node Package Manager.
    Itâ€™s the default package manager for Node.js.

    Why?
    * Install open-source packages (like express, mongoose)
    * Manage project dependencies
    * Run project scripts
    * Share your own packages
<=======

=======>
a6.
Environment Variables
    Environment Variables are key-value pairs used to store config values outside your code.
    ğŸ›¡ï¸ Useful for keeping sensitive info like passwords, API keys, and URLs secure and separate from code.

    Why?
    ğŸ”’ Security â€“ avoid hardcoding secrets
    ğŸ” Portability â€“ config changes without changing code
    ğŸ“¦ Environment-specific setup â€“ dev, staging, production
<=======

=======>
a7.
fs module
    The fs module in Node.js lets you work with the file system â€” reading, writing, updating, and deleting 
    files or folders.

    Why?
    To Read, Write, Update, and Delete operations in file system

    How?
    Using fs module
    const fs = require('fs');
<=======

=======>
a8.
path module
    The path module provides utilities for working with file and directory paths in Node.js.
    ğŸ“¦ It's a built-in module â€” no need to install it.

    Why?
    * Makes file paths OS-independent (/ on mac/linux, \\ on Windows)
    * Helps join, resolve, normalize, extract paths
    * Prevents hardcoding file paths manually

    How?
    Using path module
    const path = require('path');
<=======

=======>
a9.
events module
    * The events module allows handling custom events.
    * You can create an event, listen for it, and trigger it.
    * ğŸ“¦ It's a built-in module â€” no installation needed.

    Why?
    * Helps build event-driven systems (core idea behind Node.js)
    * Great for decoupling code â€” e.g., notify one part of your app when something happens in another

    How?
    using events module
    const EventEmitter = require('events');

    ğŸ› ï¸ How It Works
    * Create an event emitter
    * Listen for an event
    * Emit (trigger) the event
<=======

=======>
b1.
streams
    Streams are a way to read or write data piece by piece, instead of loading the entire data at once.
    ğŸ‘‰ Useful for handling large files, video/audio, network data, etc.

    Why?
    | Without Streams         | With Streams              |
    |-------------------------|---------------------------|
    | Loads all data at once  | Handles data in chunks    |
    | Can crash on big files  | Memory efficient          |
    | Slower performance      | Fast and scalable         |

    Types?
    | Stream Type       | Purpose                 |
    |-------------------|-------------------------|
    | `Readable`        | Read data (e.g. from file) |
    | `Writable`        | Write data (e.g. to file)  |
    | `Duplex`          | Both read and write       |
    | `Transform`       | Modify data while streaming (e.g. compress)

    Common Modules That Use Streams
    * fs (file system)
    * http
    * zlib (compression)
    * net
    * crypto
<=======

=======>
b2.
buffers
    A Buffer is a way to handle binary data (like images, videos, or raw files) directly in memory.
    In Node.js, buffers are used when youâ€™re dealing with streams, files, TCP sockets, or raw binary data.

    Why?
    * JavaScript normally deals with strings (text), but not raw binary.
    * Buffers help you store and manipulate binary data.
    * Very useful when working with fs, net, or stream modules.
<=======

=======>
b3.
http module
<=======

=======>
b4.
os module
<=======

=======>
b5.
child_process
<=======

=======>
b6.
cluster
<=======

=======>
b7.
process.exit()
<=======

=======>
b8.
process.argv
<=======

=======>
b9.
process.memoryUsage()
<=======

=======>
c1.
Manual Middleware
<=======

=======>
c2.
Error Handling
<=======

=======>
c3.
REST APIs
<=======